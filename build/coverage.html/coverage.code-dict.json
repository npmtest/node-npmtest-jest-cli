{"/home/travis/build/npmtest/node-npmtest-jest-cli/test.js":"/* istanbul instrument in package npmtest_jest_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jest-cli/lib.npmtest_jest_cli.js":"/* istanbul instrument in package npmtest_jest_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jest_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jest_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jest-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jest-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jest_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jest_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jest_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jest_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jest_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jest_cli.__dirname + '/lib.npmtest_jest_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/jest.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\n\nconst realFs = require('fs');\nconst fs = require('graceful-fs');\nfs.gracefulify(realFs);\n\nconst Runtime = require('jest-runtime');\nconst SearchSource = require('./SearchSource');\nconst TestRunner = require('./TestRunner');\n\nconst chalk = require('chalk');var _require =\nrequire('jest-util');const Console = _require.Console,clearLine = _require.clearLine;var _require2 =\nrequire('jest-util');const createDirectory = _require2.createDirectory;\nconst createHasteContext = require('./lib/createHasteContext');\nconst getMaxWorkers = require('./lib/getMaxWorkers');\nconst logDebugMessages = require('./lib/logDebugMessages');\nconst preRunMessage = require('./preRunMessage');\nconst readConfig = require('jest-config').readConfig;var _require3 =\nrequire('./cli');const run = _require3.run;\nconst runJest = require('./runJest');\nconst TestWatcher = require('./TestWatcher');\nconst watch = require('./watch');\n\nconst VERSION = require('../package.json').version;\n\nconst runCLI = (\nargv,\nroot,\nonComplete) =>\n{\n  const pipe = argv.json ? process.stderr : process.stdout;\n  argv = argv || {};\n  if (argv.version) {\n    pipe.write(`v${VERSION}\\n`);\n    onComplete && onComplete();\n    return;\n  }\n\n  readConfig(argv, root).\n  then((_ref) =>\n\n\n\n\n\n  {let config = _ref.config,hasDeprecationWarnings = _ref.hasDeprecationWarnings;\n    if (argv.debug) {\n      logDebugMessages(config, pipe);\n    }\n\n    createDirectory(config.cacheDirectory);\n    const jestHasteMap = Runtime.createHasteMap(config, {\n      console: new Console(pipe, pipe),\n      maxWorkers: getMaxWorkers(argv),\n      resetCache: !config.cache,\n      watch: config.watch });\n\n\n    return jestHasteMap.build().then(\n    hasteMap => createHasteContext(config, hasteMap),\n    error => {\n      throw error;\n    }).\n\n    then(hasteContext => {\n      if (argv.watch || argv.watchAll) {\n        return watch(\n        config,\n        pipe,\n        argv,\n        jestHasteMap,\n        hasteContext,\n        hasDeprecationWarnings);\n\n      } else {\n        const startRun = () => {\n          preRunMessage.print(pipe);\n          const testWatcher = new TestWatcher({ isWatchMode: false });\n          return runJest(\n          hasteContext,\n          config,\n          argv,\n          pipe,\n          testWatcher,\n          startRun,\n          onComplete);\n\n        };\n        return startRun();\n      }\n    });\n  }).\n  catch(error => {\n    clearLine(process.stderr);\n    clearLine(process.stdout);\n    console.error(chalk.red(error.stack));\n    process.exit(1);\n  });\n};\n\nmodule.exports = {\n  SearchSource,\n  TestRunner,\n  TestWatcher,\n  getVersion: () => VERSION,\n  run,\n  runCLI };","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/SearchSource.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i[\"return\"]) _i[\"return\"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}();\n\n\n\n\n\n\nconst micromatch = require('micromatch');\n\nconst DependencyResolver = require('jest-resolve-dependencies');\n\nconst chalk = require('chalk');\nconst changedFiles = require('jest-changed-files');\nconst path = require('path');var _require =\n\n\n\nrequire('jest-regex-util');const escapePathForRegex = _require.escapePathForRegex,replacePathSepForRegex = _require.replacePathSepForRegex;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst git = changedFiles.git;\nconst hg = changedFiles.hg;\n\nconst determineSCM = path => Promise.all([\ngit.isGitRepository(path),\nhg.isHGRepository(path)]);\n\nconst pathToRegex = p => replacePathSepForRegex(p);\nconst pluralize = (\nword,\ncount,\nending) =>\n`${count} ${word}${count === 1 ? '' : ending}`;\n\nconst globsToMatcher = globs => {\n  if (globs == null || globs.length === 0) {\n    return () => true;\n  }\n\n  const matchers = globs.map(each => micromatch.matcher(each));\n  return path => matchers.some(each => each(path));\n};\n\nconst regexToMatcher = testRegex => {\n  if (!testRegex) {\n    return () => true;\n  }\n\n  const regex = new RegExp(pathToRegex(testRegex));\n  return path => regex.test(path);\n};\n\nclass SearchSource {\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor(\n  hasteMap,\n  config,\n  options)\n  {\n    this._hasteContext = hasteMap;\n    this._config = config;\n    this._options = options || {\n      skipNodeResolution: false };\n\n\n    this._rootPattern =\n    new RegExp(config.roots.map(\n    dir => escapePathForRegex(dir)).\n    join('|'));\n\n    const ignorePattern = config.testPathIgnorePatterns;\n    this._testIgnorePattern =\n    ignorePattern.length ? new RegExp(ignorePattern.join('|')) : null;\n\n    this._testPathCases = {\n      roots: path => this._rootPattern.test(path),\n      testMatch: globsToMatcher(config.testMatch),\n      testPathIgnorePatterns: path =>\n      !this._testIgnorePattern ||\n      !this._testIgnorePattern.test(path),\n\n      testRegex: regexToMatcher(config.testRegex) };\n\n  }\n\n  _filterTestPathsWithStats(\n  allPaths,\n  testPathPattern)\n  {\n    const data = {\n      paths: [],\n      stats: {},\n      total: allPaths.length };\n\n\n    const testCases = Object.assign({}, this._testPathCases);\n    if (testPathPattern) {\n      const regex = new RegExp(testPathPattern, 'i');\n      testCases.testPathPattern = path => regex.test(path);\n    }\n\n    data.paths = allPaths.filter(path => {\n      return Object.keys(testCases).reduce((flag, key) => {\n        if (testCases[key](path)) {\n          data.stats[key] = ++data.stats[key] || 1;\n          return flag && true;\n        }\n        data.stats[key] = data.stats[key] || 0;\n        return false;\n      }, true);\n    });\n\n    return data;\n  }\n\n  _getAllTestPaths(\n  testPathPattern)\n  {\n    return this._filterTestPathsWithStats(\n    this._hasteContext.hasteFS.getAllFiles(),\n    testPathPattern);\n\n  }\n\n  isTestFilePath(path) {\n    return Object.keys(this._testPathCases).every(key =>\n    this._testPathCases[key](path));\n\n  }\n\n  findMatchingTests(\n  testPathPattern)\n  {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths) {\n    const dependencyResolver = new DependencyResolver(\n    this._hasteContext.resolver,\n    this._hasteContext.hasteFS);\n\n    return {\n      paths: dependencyResolver.resolveInverse(\n      allPaths,\n      this.isTestFilePath.bind(this),\n      {\n        skipNodeResolution: this._options.skipNodeResolution }) };\n\n\n\n  }\n\n  findRelatedTestsFromPattern(\n  paths)\n  {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p => path.resolve(process.cwd(), p));\n      return this.findRelatedTests(new Set(resolvedPaths));\n    }\n    return { paths: [] };\n  }\n\n  findChangedTests(options) {\n    return Promise.all(this._config.roots.map(determineSCM)).\n    then(repos => {\n      if (!repos.every((_ref) => {var _ref2 = _slicedToArray(_ref, 2);let gitRepo = _ref2[0],hgRepo = _ref2[1];return gitRepo || hgRepo;})) {\n        return {\n          noSCM: true,\n          paths: [] };\n\n      }\n      return Promise.all(Array.from(repos).map((_ref3) => {var _ref4 = _slicedToArray(_ref3, 2);let gitRepo = _ref4[0],hgRepo = _ref4[1];\n        return gitRepo ?\n        git.findChangedFiles(gitRepo, options) :\n        hg.findChangedFiles(hgRepo, options);\n      })).then(changedPathSets => this.findRelatedTests(\n      new Set(Array.prototype.concat.apply([], changedPathSets))));\n\n    });\n  }\n\n  getNoTestsFoundMessage(\n  patternInfo,\n  config,\n  data)\n  {\n    if (patternInfo.onlyChanged) {\n      return (\n        chalk.bold(\n        'No tests found related to files changed since last commit.\\n') +\n\n        chalk.dim(\n        patternInfo.watch ?\n        'Press `a` to run all tests, or run Jest with `--watchAll`.' :\n        'Run Jest without `-o` to run all tests.'));\n\n\n    }\n\n    const testPathPattern = SearchSource.getTestPathPattern(patternInfo);\n    const stats = data.stats || {};\n    const statsMessage = Object.keys(stats).map(key => {\n      const value = key === 'testPathPattern' ? testPathPattern : config[key];\n      if (value) {\n        const matches = pluralize('match', stats[key], 'es');\n        return `  ${key}: ${chalk.yellow(value)} - ${matches}`;\n      }\n      return null;\n    }).filter(line => line).join('\\n');\n\n    return (\n      chalk.bold('No tests found') + '\\n' + (\n      data.total ?\n      `  ${pluralize('file', data.total || 0, 's')} checked.\\n` +\n      statsMessage :\n      `No files found in ${config.rootDir}.\\n` +\n      `Make sure Jest's configuration does not exclude this directory.\\n` +\n      `To set up Jest, make sure a package.json file exists.\\n` +\n      `Jest Documentation: facebook.github.io/jest/docs/configuration.html`));\n\n\n  }\n\n  getTestPaths(patternInfo) {\n    if (patternInfo.onlyChanged) {\n      return this.findChangedTests({ lastCommit: patternInfo.lastCommit });\n    } else if (patternInfo.findRelatedTests && patternInfo.paths) {\n      return Promise.resolve(\n      this.findRelatedTestsFromPattern(patternInfo.paths));\n\n    } else if (patternInfo.testPathPattern != null) {\n      return Promise.resolve(\n      this.findMatchingTests(patternInfo.testPathPattern));\n\n    } else {\n      return Promise.resolve({ paths: [] });\n    }\n  }\n\n  static getTestPathPattern(patternInfo) {\n    const pattern = patternInfo.testPathPattern;\n    const input = patternInfo.input;\n    const formattedPattern = `/${pattern || ''}/`;\n    const formattedInput = patternInfo.shouldTreatInputAsPattern ?\n    `/${input || ''}/` :\n    `\"${input || ''}\"`;\n    return input === pattern ? formattedInput : formattedPattern;\n  }}\n\n\n\nmodule.exports = SearchSource;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/TestRunner.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';var _require =\n\n\n\n\n\n\n\n\n\n\n\nrequire('jest-message-util');const formatExecError = _require.formatExecError;\nconst fs = require('graceful-fs');\nconst getCacheFilePath = require('jest-haste-map').getCacheFilePath;\nconst DefaultReporter = require('./reporters/DefaultReporter');\nconst NotifyReporter = require('./reporters/NotifyReporter');\nconst SummaryReporter = require('./reporters/SummaryReporter');\nconst VerboseReporter = require('./reporters/VerboseReporter');\nconst promisify = require('./lib/promisify');\nconst runTest = require('./runTest');\nconst snapshot = require('jest-snapshot');\nconst throat = require('throat');\nconst workerFarm = require('worker-farm');\nconst TestWatcher = require('./TestWatcher');\n\nconst FAIL = 0;\nconst SLOW_TEST_TIME = 3000;\nconst SUCCESS = 1;\n\nclass CancelRun extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CancelRun';\n  }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst TEST_WORKER_PATH = require.resolve('./TestWorker');\n\nclass TestRunner {\n\n\n\n\n\n\n\n  constructor(\n  hasteContext,\n  config,\n  options,\n  startRun)\n  {\n    this._config = config;\n    this._dispatcher = new ReporterDispatcher(\n    hasteContext.hasteFS,\n    options.getTestSummary);\n\n    this._hasteContext = hasteContext;\n    this._options = options;\n    this._startRun = startRun;\n    this._setupReporters();\n\n    // Map from testFilePath -> time it takes to run the test. Used to\n    // optimally schedule bigger test runs.\n    this._testPerformanceCache = {};\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  _getTestPerformanceCachePath() {\n    const config = this._config;\n    return getCacheFilePath(config.cacheDirectory, 'perf-cache-' + config.name);\n  }\n\n  _sortTests(testPaths) {\n    // When running more tests than we have workers available, sort the tests\n    // by size - big test files usually take longer to complete, so we run\n    // them first in an effort to minimize worker idle time at the end of a\n    // long test run.\n    //\n    // After a test run we store the time it took to run a test and on\n    // subsequent runs we use that to run the slowest tests first, yielding the\n    // fastest results.\n    try {\n      if (this._config.cache) {\n        this._testPerformanceCache = JSON.parse(fs.readFileSync(\n        this._getTestPerformanceCachePath(),\n        'utf8'));\n\n      } else {\n        this._testPerformanceCache = {};\n      }\n    } catch (e) {\n      this._testPerformanceCache = {};\n    }\n\n    const cache = this._testPerformanceCache;\n    const timings = [];\n    const stats = {};\n    const getFileSize = filePath =>\n    stats[filePath] || (stats[filePath] = fs.statSync(filePath).size);\n    const getTestRunTime = filePath => {\n      if (cache[filePath]) {\n        return cache[filePath][0] === FAIL ? Infinity : cache[filePath][1];\n      }\n      return null;\n    };\n\n    testPaths = testPaths.\n    sort((pathA, pathB) => {\n      const timeA = getTestRunTime(pathA);\n      const timeB = getTestRunTime(pathB);\n      if (timeA != null && timeB != null) {\n        return timeA < timeB ? 1 : -1;\n      }\n      return getFileSize(pathA) < getFileSize(pathB) ? 1 : -1;\n    });\n\n    testPaths.forEach(filePath => {\n      const timing = cache[filePath] && cache[filePath][1];\n      if (timing) {\n        timings.push(timing);\n      }\n    });\n\n    return { testPaths, timings };\n  }\n\n  _cacheTestResults(aggregatedResults) {\n    const cache = this._testPerformanceCache;\n    aggregatedResults.testResults.forEach(test => {\n      if (test && !test.skipped) {\n        const perf = test.perfStats;\n        cache[test.testFilePath] = [\n        test.numFailingTests ? FAIL : SUCCESS,\n        perf.end - perf.start || 0];\n\n      }\n    });\n    fs.writeFileSync(\n    this._getTestPerformanceCachePath(),\n    JSON.stringify(cache));\n\n  }\n\n  runTests(paths, watcher) {\n    const config = this._config;var _sortTests =\n    this._sortTests(paths);const testPaths = _sortTests.testPaths,timings = _sortTests.timings;\n    const aggregatedResults = createAggregatedResults(testPaths.length);\n    const estimatedTime =\n    Math.ceil(getEstimatedTime(timings, this._options.maxWorkers) / 1000);\n\n    const onResult = (testPath, testResult) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        onFailure(testPath, {\n          message,\n          stack: new Error(message).stack });\n\n        return;\n      }\n      addResult(aggregatedResults, testResult);\n      this._dispatcher.onTestResult(\n      config,\n      testResult,\n      aggregatedResults);\n\n      this._bailIfNeeded(aggregatedResults, watcher);\n    };\n\n    const onFailure = (testPath, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n      const testResult = buildFailureTestResult(testPath, error);\n      testResult.failureMessage = formatExecError(testResult, config, testPath);\n      addResult(aggregatedResults, testResult);\n      this._dispatcher.onTestResult(\n      config,\n      testResult,\n      aggregatedResults);\n\n    };\n\n    // Run in band if we only have one test or one worker available.\n    // If we are confident from previous runs that the tests will finish quickly\n    // we also run in band to reduce the overhead of spawning workers.\n    const shouldRunInBand = () =>\n    this._options.maxWorkers <= 1 ||\n    testPaths.length <= 1 ||\n\n    testPaths.length <= 20 &&\n    timings.length > 0 && timings.every(timing => timing < SLOW_TEST_TIME);\n\n\n\n    const updateSnapshotState = () => {\n      const status =\n      snapshot.cleanup(this._hasteContext.hasteFS, config.updateSnapshot);\n      aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n      aggregatedResults.snapshot.didUpdate = config.updateSnapshot;\n      aggregatedResults.snapshot.failure = !!(\n      !aggregatedResults.snapshot.didUpdate && (\n      aggregatedResults.snapshot.unchecked ||\n      aggregatedResults.snapshot.unmatched ||\n      aggregatedResults.snapshot.filesRemoved));\n\n\n    };\n\n    const runInBand = shouldRunInBand();\n\n    this._dispatcher.onRunStart(\n    config,\n    aggregatedResults,\n    {\n      estimatedTime,\n      showStatus: !runInBand });\n\n\n\n    const testRun =\n    runInBand ?\n    this._createInBandTestRun(testPaths, watcher, onResult, onFailure) :\n    this._createParallelTestRun(testPaths, watcher, onResult, onFailure);\n\n    return testRun.\n    catch(error => {\n      if (!watcher.isInterrupted()) {\n        throw error;\n      }\n    }).\n    then(() => {\n      updateSnapshotState();\n      aggregatedResults.wasInterrupted = watcher.isInterrupted();\n\n      this._dispatcher.onRunComplete(config, aggregatedResults);\n\n      const anyTestFailures = !(\n      aggregatedResults.numFailedTests === 0 &&\n      aggregatedResults.numRuntimeErrorTestSuites === 0);\n\n      const anyReporterErrors = this._dispatcher.hasErrors();\n\n      aggregatedResults.success = !(\n      anyTestFailures ||\n      aggregatedResults.snapshot.failure ||\n      anyReporterErrors);\n\n\n      this._cacheTestResults(aggregatedResults);\n      return aggregatedResults;\n    });\n  }\n\n  _createInBandTestRun(\n  testPaths,\n  watcher,\n  onResult,\n  onFailure)\n  {\n    const mutex = throat(1);\n    return testPaths.reduce(\n    (promise, path) =>\n    mutex(() =>\n    promise.\n    then(() => {\n      if (watcher.isInterrupted()) {\n        throw new CancelRun();\n      }\n\n      this._dispatcher.onTestStart(this._config, path);\n      return runTest(\n      path,\n      this._config,\n      this._hasteContext.resolver);\n\n    }).\n    then(result => onResult(path, result)).\n    catch(err => onFailure(path, err))),\n\n    Promise.resolve());\n\n  }\n\n  _createParallelTestRun(\n  testPaths,\n  watcher,\n  onResult,\n  onFailure)\n  {\n    const config = this._config;\n    const farm = workerFarm({\n      autoStart: true,\n      maxConcurrentCallsPerWorker: 1,\n      maxConcurrentWorkers: this._options.maxWorkers,\n      maxRetries: 2 },\n    TEST_WORKER_PATH);\n    const mutex = throat(this._options.maxWorkers);\n    const worker = promisify(farm);\n\n    // Send test suites to workers continuously instead of all at once to track\n    // the start time of individual tests.\n    const runTestInWorker = (_ref) => {let config = _ref.config,path = _ref.path;return mutex(() => {\n        if (watcher.isInterrupted()) {\n          return Promise.reject();\n        }\n        this._dispatcher.onTestStart(config, path);\n        return worker({\n          config,\n          path,\n          rawModuleMap: watcher.isWatchMode() ?\n          this._hasteContext.moduleMap.getRawModuleMap() :\n          null });\n\n      });};\n\n    const onError = (err, path) => {\n      onFailure(path, err);\n      if (err.type === 'ProcessTerminatedError') {\n        console.error(\n        'A worker process has quit unexpectedly! ' +\n        'Most likely this an initialization error.');\n\n        process.exit(1);\n      }\n    };\n\n    const onInterrupt = new Promise((_, reject) => {\n      watcher.on('change', state => {\n        if (state.interrupted) {\n          reject(new CancelRun());\n        }\n      });\n    });\n\n    const runAllTests = Promise.all(testPaths.map(path => {\n      return runTestInWorker({ config, path }).\n      then(testResult => onResult(path, testResult)).\n      catch(error => onError(error, path));\n    }));\n\n    const cleanup = () => workerFarm.end(farm);\n\n    return Promise.race([\n    runAllTests,\n    onInterrupt]).\n    then(cleanup, cleanup);\n  }\n\n  _setupReporters() {\n    const config = this._config;\n\n    this.addReporter(\n    config.verbose ?\n    new VerboseReporter(config) :\n    new DefaultReporter());\n\n\n    if (config.collectCoverage) {\n      // coverage reporter dependency graph is pretty big and we don't\n      // want to require it if we're not in the `--coverage` mode\n      const CoverageReporter = require('./reporters/CoverageReporter');\n      this.addReporter(new CoverageReporter());\n    }\n\n    this.addReporter(new SummaryReporter());\n    if (config.notify) {\n      this.addReporter(new NotifyReporter(this._startRun));\n    }\n  }\n\n  _bailIfNeeded(aggregatedResults, watcher) {\n    if (this._config.bail && aggregatedResults.numFailedTests !== 0) {\n      if (watcher.isWatchMode()) {\n        watcher.setState({ interrupted: true });\n      } else {\n        this._dispatcher.onRunComplete(this._config, aggregatedResults);\n        process.exit(1);\n      }\n    }\n  }}\n\n\nconst createAggregatedResults = numTotalTestSuites => {\n  return {\n    numFailedTestSuites: 0,\n    numFailedTests: 0,\n    numPassedTestSuites: 0,\n    numPassedTests: 0,\n    numPendingTestSuites: 0,\n    numPendingTests: 0,\n    numRuntimeErrorTestSuites: 0,\n    numTotalTestSuites,\n    numTotalTests: 0,\n    snapshot: {\n      added: 0,\n      didUpdate: false, // is set only after the full run\n      failure: false,\n      filesAdded: 0,\n      // combines individual test results + results after full run\n      filesRemoved: 0,\n      filesUnmatched: 0,\n      filesUpdated: 0,\n      matched: 0,\n      total: 0,\n      unchecked: 0,\n      unmatched: 0,\n      updated: 0 },\n\n    startTime: Date.now(),\n    success: false,\n    testResults: [],\n    wasInterrupted: false };\n\n};\n\nconst addResult = (\naggregatedResults,\ntestResult) =>\n{\n  aggregatedResults.testResults.push(testResult);\n  aggregatedResults.numTotalTests +=\n  testResult.numPassingTests +\n  testResult.numFailingTests +\n  testResult.numPendingTests;\n  aggregatedResults.numFailedTests += testResult.numFailingTests;\n  aggregatedResults.numPassedTests += testResult.numPassingTests;\n  aggregatedResults.numPendingTests += testResult.numPendingTests;\n\n  if (testResult.testExecError) {\n    aggregatedResults.numRuntimeErrorTestSuites++;\n  }\n\n  if (testResult.skipped) {\n    aggregatedResults.numPendingTestSuites++;\n  } else if (testResult.numFailingTests > 0 || testResult.testExecError) {\n    aggregatedResults.numFailedTestSuites++;\n  } else {\n    aggregatedResults.numPassedTestSuites++;\n  }\n\n  // Snapshot data\n  if (testResult.snapshot.added) {\n    aggregatedResults.snapshot.filesAdded++;\n  }\n  if (testResult.snapshot.fileDeleted) {\n    aggregatedResults.snapshot.filesRemoved++;\n  }\n  if (testResult.snapshot.unmatched) {\n    aggregatedResults.snapshot.filesUnmatched++;\n  }\n  if (testResult.snapshot.updated) {\n    aggregatedResults.snapshot.filesUpdated++;\n  }\n\n  aggregatedResults.snapshot.added += testResult.snapshot.added;\n  aggregatedResults.snapshot.matched += testResult.snapshot.matched;\n  aggregatedResults.snapshot.unchecked += testResult.snapshot.unchecked;\n  aggregatedResults.snapshot.unmatched += testResult.snapshot.unmatched;\n  aggregatedResults.snapshot.updated += testResult.snapshot.updated;\n  aggregatedResults.snapshot.total +=\n  testResult.snapshot.added +\n  testResult.snapshot.matched +\n  testResult.snapshot.unmatched +\n  testResult.snapshot.updated;\n};\n\nconst buildFailureTestResult = (\ntestPath,\nerr) =>\n{\n  return {\n    console: null,\n    failureMessage: null,\n    numFailingTests: 0,\n    numPassingTests: 0,\n    numPendingTests: 0,\n    perfStats: {\n      end: 0,\n      start: 0 },\n\n    skipped: false,\n    snapshot: {\n      added: 0,\n      fileDeleted: false,\n      matched: 0,\n      unchecked: 0,\n      unmatched: 0,\n      updated: 0 },\n\n    testExecError: err,\n    testFilePath: testPath,\n    testResults: [] };\n\n};\n\n// Proxy class that holds all reporter and dispatchers events to each\n// of them.\nclass ReporterDispatcher {\n\n\n\n\n  constructor(hasteFS, getTestSummary) {\n    this._runnerContext = { getTestSummary, hasteFS };\n    this._reporters = [];\n  }\n\n  register(reporter) {\n    this._reporters.push(reporter);\n  }\n\n  unregister(ReporterClass) {\n    this._reporters = this._reporters.filter(\n    reporter => !(reporter instanceof ReporterClass));\n\n  }\n\n  onTestResult(config, testResult, results) {\n    this._reporters.forEach(reporter =>\n    reporter.onTestResult(\n    config,\n    testResult,\n    results,\n    this._runnerContext));\n\n\n  }\n\n  onTestStart(config, path) {\n    this._reporters.forEach(reporter =>\n    reporter.onTestStart(config, path, this._runnerContext));\n\n  }\n\n  onRunStart(config, results, options) {\n    this._reporters.forEach(\n    reporter => reporter.onRunStart(\n    config,\n    results,\n    this._runnerContext,\n    options));\n\n\n  }\n\n  onRunComplete(config, results) {\n    this._reporters.forEach(reporter =>\n    reporter.onRunComplete(config, results, this._runnerContext));\n\n  }\n\n  // Return a list of last errors for every reporter\n  getErrors() {\n    return this._reporters.reduce(\n    (list, reporter) => {\n      const error = reporter.getLastError();\n      return error ? list.concat(error) : list;\n    },\n    []);\n\n  }\n\n  hasErrors() {\n    return this.getErrors().length !== 0;\n  }}\n\n\nconst getEstimatedTime = (timings, workers) => {\n  if (!timings.length) {\n    return 0;\n  }\n\n  const max = Math.max.apply(null, timings);\n  if (timings.length <= workers) {\n    return max;\n  }\n\n  return Math.max(\n  timings.reduce((sum, time) => sum + time) / workers,\n  max);\n\n};\n\nmodule.exports = TestRunner;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/DefaultReporter.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n/* global stream$Writable, tty$WriteStream */\n\n'use strict';\n\n\n\n\n\nconst BaseReporter = require('./BaseReporter');\nconst Status = require('./Status');var _require =\n\nrequire('jest-util');const clearLine = _require.clearLine;\nconst chalk = require('chalk');\nconst getConsoleOutput = require('./getConsoleOutput');\nconst getResultHeader = require('./getResultHeader');\nconst isCI = require('is-ci');\n\n\n\nconst TITLE_BULLET = chalk.bold('\\u25cf ');\n\nconst isInteractive = process.stdin.isTTY && !isCI;\n\nclass DefaultReporter extends BaseReporter {\n  // ANSI clear sequence for the last printed status\n\n\n\n\n\n\n\n  constructor() {\n    super();\n    this._clear = '';\n    this._out = process.stdout.write.bind(process.stdout);\n    this._err = process.stderr.write.bind(process.stderr);\n    this._status = new Status();\n    this._wrapStdio(process.stdout);\n    this._wrapStdio(process.stderr);\n    this._status.onChange(() => {\n      this._clearStatus();\n      this._printStatus();\n    });\n  }\n\n  _wrapStdio(stream) {\n    const originalWrite = stream.write;\n\n    let buffer = [];\n    let timeout = null;\n\n    const doFlush = () => {\n      const string = buffer.join('');\n      buffer = [];\n      // This is to avoid conflicts between random output and status text\n      this._clearStatus();\n      originalWrite.call(stream, string);\n      this._printStatus();\n    };\n\n    const flush = () => {\n      // If the process blows up no errors would be printed.\n      // There should be a smart way to buffer stderr, but for now\n      // we just won't buffer it.\n      if (stream === process.stderr) {\n        doFlush();\n      } else {\n        if (!timeout) {\n          timeout = setTimeout(() => {\n            doFlush();\n            timeout = null;\n          }, 100);\n        }\n      }\n    };\n\n    // $FlowFixMe\n    stream.write = chunk => {\n      buffer.push(chunk);\n      flush();\n      return true;\n    };\n  }\n\n  _clearStatus() {\n    if (isInteractive) {\n      this._out(this._clear);\n    }\n  }\n\n  _printStatus() {var _status$get =\n    this._status.get();const content = _status$get.content,clear = _status$get.clear;\n    this._clear = clear;\n    if (isInteractive) {\n      this._out(content);\n    }\n  }\n\n  onRunStart(\n  config,\n  aggregatedResults,\n  runnerContext,\n  options)\n  {\n    this._status.runStarted(aggregatedResults, options);\n  }\n\n  onTestStart(config, testPath) {\n    this._status.testStarted(testPath, config);\n  }\n\n  onRunComplete() {\n    this._status.runFinished();\n    // $FlowFixMe\n    process.stdout.write = this._out;\n    // $FlowFixMe\n    process.stderr.write = this._err;\n    clearLine(process.stderr);\n  }\n\n  onTestResult(\n  config,\n  testResult,\n  aggregatedResults)\n  {\n    this._status.testFinished(config, testResult, aggregatedResults);\n    this._printTestFileSummary(testResult.testFilePath, config, testResult);\n  }\n\n  _printTestFileSummary(\n  testPath,\n  config,\n  result)\n  {\n    if (!result.skipped) {\n      this.log(getResultHeader(result, config));\n\n      const consoleBuffer = result.console;\n      if (consoleBuffer && consoleBuffer.length) {\n        this.log(\n        '  ' + TITLE_BULLET + 'Console\\n\\n' +\n        getConsoleOutput(\n        config.rootDir,\n        !!config.verbose,\n        consoleBuffer));\n\n\n      }\n\n      if (result.failureMessage) {\n        this.log(result.failureMessage);\n      }\n    }\n  }}\n\n\nmodule.exports = DefaultReporter;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/BaseReporter.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\n\n\nconst preRunMessage = require('../preRunMessage');\n\nclass BaseReporter {\n\n\n  log(message) {\n    process.stderr.write(message + '\\n');\n  }\n\n  onRunStart(\n  config,\n  results,\n  runnerContext,\n  options)\n  {\n    preRunMessage.remove(process.stderr);\n  }\n\n  onTestResult(\n  config,\n  testResult,\n  results)\n  {}\n\n  onTestStart(\n  config,\n  path,\n  runnerContext)\n  {}\n\n  onRunComplete(\n  config,\n  aggregatedResults,\n  runnerContext)\n  {}\n\n  _setError(error) {\n    this._error = error;\n  }\n\n  // Return an error that occured during reporting. This error will\n  // define whether the test run was successful or failed.\n  getLastError() {\n    return this._error;\n  }}\n\n\nmodule.exports = BaseReporter;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/preRunMessage.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';var _require =\n\nrequire('jest-util');const clearLine = _require.clearLine;\nconst chalk = require('chalk');\nconst isCI = require('is-ci');\n\nconst print = stream => {\n  if (process.stdout.isTTY && !isCI) {\n    stream.write(chalk.bold.dim('Determining test suites to run...'));\n  }\n};\n\nconst remove = stream => {\n  if (stream.isTTY && !isCI) {\n    clearLine(stream);\n  }\n};\n\nmodule.exports = {\n  print,\n  remove };","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/Status.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';var _require =\n\n\n\n\n\nrequire('./utils');const getSummary = _require.getSummary,trimAndFormatPath = _require.trimAndFormatPath,wrapAnsiString = _require.wrapAnsiString;\nconst chalk = require('chalk');\n\nconst RUNNING_TEXT = ' RUNS ';\nconst RUNNING = chalk.reset.inverse.yellow.bold(RUNNING_TEXT) + ' ';\n\n/**\n                                                                      * This class is a perf optimization for sorting the list of currently\n                                                                      * running tests. It tries to keep tests in the same positions without\n                                                                      * shifting the whole list.\n                                                                      */\nclass CurrentTestList {\n\n\n  constructor() {\n    this._array = [];\n  }\n\n  add(testPath, config) {\n    const index = this._array.indexOf(null);\n    const record = { config, testPath };\n    if (index !== -1) {\n      this._array[index] = record;\n    } else {\n      this._array.push(record);\n    }\n  }\n\n  delete(testPath) {\n    const record = this._array.find(\n    record => record && record.testPath === testPath);\n\n    this._array[this._array.indexOf(record || null)] = null;\n  }\n\n  get() {\n    return this._array;\n  }}\n\n\n/**\n      * A class that generates the CLI status of currently running tests\n      * and also provides an ANSI escape sequence to remove status lines\n      * from the terminal.\n      */\nclass Status {\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor() {\n    this._cache = null;\n    this._currentTests = new CurrentTestList();\n    this._done = false;\n    this._emitScheduled = false;\n    this._estimatedTime = 0;\n    this._height = 0;\n    this._showStatus = false;\n  }\n\n  onChange(callback) {\n    this._callback = callback;\n  }\n\n  runStarted(\n  aggregatedResults,\n  options)\n  {\n    this._estimatedTime = options && options.estimatedTime || 0;\n    this._showStatus = options && options.showStatus;\n    this._interval = setInterval(() => this._tick(), 1000);\n    this._aggregatedResults = aggregatedResults;\n    this._debouncedEmit();\n  }\n\n  runFinished() {\n    this._done = true;\n    clearInterval(this._interval);\n    this._emit();\n  }\n\n  testStarted(testPath, config) {\n    this._currentTests.add(testPath, config);\n    if (!this._showStatus) {\n      this._emit();\n    } else {\n      this._debouncedEmit();\n    }\n  }\n\n  testFinished(\n  config,\n  testResult,\n  aggregatedResults)\n  {const\n    testFilePath = testResult.testFilePath;\n    this._aggregatedResults = aggregatedResults;\n    this._currentTests.delete(testFilePath);\n    this._debouncedEmit();\n  }\n\n  get() {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    if (this._done) {\n      return { clear: '', content: '' };\n    }\n\n    // $FlowFixMe\n    const width = process.stdout.columns;\n    let content = '\\n';\n    this._currentTests.get().forEach(record => {\n      if (record) {const\n        config = record.config,testPath = record.testPath;\n        content += wrapAnsiString(\n        RUNNING + trimAndFormatPath(\n        RUNNING_TEXT.length + 1,\n        config,\n        testPath,\n        width),\n\n        width) +\n        '\\n';\n      }\n    });\n\n    if (this._showStatus && this._aggregatedResults) {\n      content += '\\n' + getSummary(\n      this._aggregatedResults,\n      {\n        estimatedTime: this._estimatedTime,\n        roundTime: true,\n        width });\n\n\n    }\n\n    let height = 0;\n\n    for (let i = 0; i < content.length; i++) {\n      if (content[i] === '\\n') {\n        height++;\n      }\n    }\n\n    const clear = '\\r\\x1B[K\\r\\x1B[1A'.repeat(height);\n    return this._cache = { clear, content };\n  }\n\n  _emit() {\n    this._cache = null;\n    this._lastUpdated = Date.now();\n    this._callback();\n  }\n\n  _debouncedEmit() {\n    if (!this._emitScheduled) {\n      // Perf optimization to avoid two separate renders When\n      // one test finishes and another test starts executing.\n      this._emitScheduled = true;\n      setTimeout(() => {\n        this._emit();\n        this._emitScheduled = false;\n      }, 100);\n    }\n  }\n\n  _tick() {\n    this._debouncedEmit();\n  }}\n\n\n\nmodule.exports = Status;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/utils.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i[\"return\"]) _i[\"return\"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}();\n\n\n\n\nconst chalk = require('chalk');\nconst path = require('path');\nconst slash = require('slash');\n\n\n\n\n\n\n\nconst PROGRESS_BAR_WIDTH = 40;\n\nconst trimAndFormatPath = (\npad,\nconfig,\ntestPath,\ncolumns) =>\n{\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);const\n  basename = relative.basename;let\n  dirname = relative.dirname;\n\n  // length is ok\n  if ((dirname + path.sep + basename).length <= maxLength) {\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  // we can fit trimmed dirname and full basename\n  const basenameLength = basename.length;\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = '...' +\n    dirname.slice(dirname.length - dirnameLength, dirname.length);\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return slash(chalk.dim('...' + path.sep) + chalk.bold(basename));\n  }\n\n  // can't fit dirname, but can fit trimmed basename\n  return slash(chalk.bold(\n  '...' +\n  basename.slice(basename.length - maxLength - 4, basename.length)));\n\n};\n\nconst formatTestPath = (config, testPath) => {var _relativePath =\n  relativePath(config, testPath);const dirname = _relativePath.dirname,basename = _relativePath.basename;\n  return chalk.dim(dirname + path.sep) + chalk.bold(basename);\n};\n\nconst relativePath = (config, testPath) => {\n  testPath = path.relative(config.rootDir, testPath);\n  const dirname = path.dirname(testPath);\n  const basename = path.basename(testPath);\n  return { basename, dirname };\n};\n\nconst pluralize = (word, count) =>\n`${count} ${word}${count === 1 ? '' : 's'}`;\n\nconst getSummary = (\naggregatedResults,\noptions) =>\n{\n  let runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n  if (options && options.roundTime) {\n    runTime = Math.floor(runTime);\n  }\n\n  const estimatedTime = options && options.estimatedTime || 0;\n  const snapshotResults = aggregatedResults.snapshot;\n  const snapshotsAdded = snapshotResults.added;\n  const snapshotsFailed = snapshotResults.unmatched;\n  const snapshotsPassed = snapshotResults.matched;\n  const snapshotsTotal = snapshotResults.total;\n  const snapshotsUpdated = snapshotResults.updated;\n  const suitesFailed = aggregatedResults.numFailedTestSuites;\n  const suitesPassed = aggregatedResults.numPassedTestSuites;\n  const suitesPending = aggregatedResults.numPendingTestSuites;\n  const suitesRun = suitesFailed + suitesPassed;\n  const suitesTotal = aggregatedResults.numTotalTestSuites;\n  const testsFailed = aggregatedResults.numFailedTests;\n  const testsPassed = aggregatedResults.numPassedTests;\n  const testsPending = aggregatedResults.numPendingTests;\n  const testsTotal = aggregatedResults.numTotalTests;\n  const width = options && options.width || 0;\n\n  const suites =\n  chalk.bold('Test Suites: ') + (\n  suitesFailed ? chalk.bold.red(`${suitesFailed} failed`) + ', ' : '') + (\n  suitesPending ?\n  chalk.bold.yellow(`${suitesPending} skipped`) + ', ' :\n  '') + (\n\n  suitesPassed ?\n  chalk.bold.green(`${suitesPassed} passed`) + ', ' :\n  '') + (\n\n  suitesRun !== suitesTotal ?\n  suitesRun + ' of ' + suitesTotal :\n  suitesTotal) +\n  ` total`;\n\n  const tests =\n  chalk.bold('Tests:       ') + (\n  testsFailed ? chalk.bold.red(`${testsFailed} failed`) + ', ' : '') + (\n  testsPending ?\n  chalk.bold.yellow(`${testsPending} skipped`) + ', ' :\n  '') + (\n\n  testsPassed ?\n  chalk.bold.green(`${testsPassed} passed`) + ', ' :\n  '') +\n\n  `${testsTotal} total`;\n\n  const snapshots =\n  chalk.bold('Snapshots:   ') + (\n  snapshotsFailed ?\n  chalk.bold.red(`${snapshotsFailed} failed`) + ', ' :\n  '') + (\n\n  snapshotsUpdated ?\n  chalk.bold.green(`${snapshotsUpdated} updated`) + ', ' :\n  '') + (\n\n  snapshotsAdded ?\n  chalk.bold.green(`${snapshotsAdded} added`) + ', ' :\n  '') + (\n\n  snapshotsPassed ?\n  chalk.bold.green(`${snapshotsPassed} passed`) + ', ' :\n  '') +\n\n  `${snapshotsTotal} total`;\n\n  const time = renderTime(runTime, estimatedTime, width);\n  return [suites, tests, snapshots, time].join('\\n');\n};\n\nconst renderTime = (\nrunTime,\nestimatedTime,\nwidth) =>\n{\n  // If we are more than one second over the estimated time, highlight it.\n  const renderedTime = estimatedTime && runTime >= estimatedTime + 1 ?\n  chalk.bold.yellow(runTime + 's') :\n  runTime + 's';\n  let time = chalk.bold(`Time:`) + `        ${renderedTime}`;\n  if (runTime < estimatedTime) {\n    time += `, estimated ${estimatedTime}s`;\n  }\n\n  // Only show a progress bar if the test run is actually going to take\n  // some time.\n  if (\n  estimatedTime > 2 &&\n  runTime < estimatedTime &&\n  width)\n  {\n    const availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);\n    const length = Math.min(\n    Math.floor(runTime / estimatedTime * availableWidth),\n    availableWidth);\n\n    if (availableWidth >= 2) {\n      time +=\n      '\\n' +\n      chalk.green.inverse(' ').repeat(length) +\n      chalk.white.inverse(' ').repeat(availableWidth - length);\n    }\n  }\n  return time;\n};\n\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nconst wrapAnsiString = (string, terminalWidth) => {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/g;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while (match = ANSI_REGEXP.exec(string)) {\n    const ansi = match[0];\n    const index = match['index'];\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n\n  return tokens.reduce(\n  (lines, _ref) => {var _ref2 = _slicedToArray(_ref, 2);let kind = _ref2[0],token = _ref2[1];\n    if (kind === 'string') {\n      if (lastLineLength + token.length > terminalWidth) {\n\n        while (token.length) {\n          const chunk = token.slice(0, terminalWidth - lastLineLength);\n          const remaining = token.slice(\n          terminalWidth - lastLineLength,\n          token.length);\n\n          lines[lines.length - 1] += chunk;\n          lastLineLength += chunk.length;\n          token = remaining;\n          if (token.length) {\n            lines.push('');\n            lastLineLength = 0;\n          }\n        }\n      } else {\n        lines[lines.length - 1] += token;\n        lastLineLength += token.length;\n      }\n    } else {\n      lines[lines.length - 1] += token;\n    }\n\n    return lines;\n  },\n  ['']).\n  join('\\n');\n};\n\nmodule.exports = {\n  formatTestPath,\n  getSummary,\n  pluralize,\n  relativePath,\n  trimAndFormatPath,\n  wrapAnsiString };","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/getConsoleOutput.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\nconst chalk = require('chalk');\nconst path = require('path');\n\nmodule.exports = (root, verbose, buffer) => {\n  const TITLE_INDENT = verbose ? '  ' : '    ';\n  const CONSOLE_INDENT = TITLE_INDENT + '  ';\n\n  return buffer.reduce((output, _ref) => {let type = _ref.type,message = _ref.message,origin = _ref.origin;\n    origin = path.relative(root, origin);\n    message = message.\n    split(/\\n/).\n    map(line => CONSOLE_INDENT + line).\n    join('\\n');\n\n    let typeMessage = 'console.' + type;\n    if (type === 'warn') {\n      message = chalk.yellow(message);\n      typeMessage = chalk.yellow(typeMessage);\n    } else if (type === 'error') {\n      message = chalk.red(message);\n      typeMessage = chalk.red(typeMessage);\n    }\n\n    return (\n      output + TITLE_INDENT + chalk.dim(typeMessage) +\n      ' ' + chalk.dim(origin) + '\\n' + message + '\\n');\n\n  }, '');\n};","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/getResultHeader.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';var _require =\n\n\n\n\nrequire('./utils');const formatTestPath = _require.formatTestPath;\nconst chalk = require('chalk');\n\nconst LONG_TEST_COLOR = chalk.reset.bold.bgRed;\n// Explicitly reset for these messages since they can get written out in the\n// middle of error logging\nconst FAIL = chalk.reset.inverse.bold.red(' FAIL ');\nconst PASS = chalk.reset.inverse.bold.green(' PASS ');\n\nmodule.exports = (result, config) => {\n  const testPath = result.testFilePath;\n  const status = result.numFailingTests > 0 || result.testExecError ?\n  FAIL :\n  PASS;\n\n  const runTime = result.perfStats ?\n  (result.perfStats.end - result.perfStats.start) / 1000 :\n  null;\n\n  const testDetail = [];\n  if (runTime !== null && runTime > 5) {\n    testDetail.push(LONG_TEST_COLOR(runTime + 's'));\n  }\n\n  if (result.memoryUsage) {\n    const toMB = bytes => Math.floor(bytes / 1024 / 1024);\n    testDetail.push(`${toMB(result.memoryUsage)} MB heap size`);\n  }\n\n  return (\n    `${status} ${formatTestPath(config, testPath)}` + (\n    testDetail.length ? ` (${testDetail.join(', ')})` : ''));\n\n};","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/NotifyReporter.js":"/**\n* Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n*\n* This source code is licensed under the BSD-style license found in the\n* LICENSE file in the root directory of this source tree. An additional grant\n* of patent rights can be found in the PATENTS file in the same directory.\n*\n* \n*/\n'use strict';\n\n\n\n\nconst BaseReporter = require('./BaseReporter');\nconst notifier = require('node-notifier');\nconst path = require('path');\nconst util = require('util');\n\nconst isDarwin = process.platform === 'darwin';\n\nconst icon = path.resolve(__dirname, '../assets/jest_logo.png');\n\nclass NotifyReporter extends BaseReporter {\n\n\n  constructor(startRun) {\n    super();\n    this._startRun = startRun;\n  }\n\n  onRunComplete(config, result) {\n    const success = result.numFailedTests === 0 &&\n    result.numRuntimeErrorTestSuites === 0;\n\n    if (success) {\n      const title = util.format('%d%% Passed', 100);\n      const message = util.format(\n      (isDarwin ? '\\u2705 ' : '') + '%d tests passed',\n      result.numPassedTests);\n\n\n      notifier.notify({ icon, message, title });\n    } else {\n      const failed = result.numFailedTests / result.numTotalTests;\n\n      const title = util.format(\n      '%d%% Failed',\n      Math.ceil(Number.isNaN(failed) ? 0 : failed * 100));\n\n      const message = util.format(\n      (isDarwin ? '\\u26D4\\uFE0F ' : '') + '%d of %d tests failed',\n      result.numFailedTests,\n      result.numTotalTests);\n\n\n      const restartAnswer = 'Run again';\n      const quitAnswer = 'Exit tests';\n      notifier.notify({\n        actions: [restartAnswer, quitAnswer],\n        closeLabel: 'Close',\n        icon,\n        message,\n        title },\n      (err, _, metadata) => {\n        if (err || !metadata) {\n          return;\n        }\n        if (metadata.activationValue === quitAnswer) {\n          process.exit(0);\n          return;\n        }\n        if (metadata.activationValue === restartAnswer) {\n          this._startRun();\n        }\n      });\n    }\n  }}\n\n\nmodule.exports = NotifyReporter;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/SummaryReporter.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\n\n\nconst BaseReporter = require('./BaseReporter');var _require =\n\nrequire('./utils');const getSummary = _require.getSummary,pluralize = _require.pluralize;\nconst chalk = require('chalk');\nconst getResultHeader = require('./getResultHeader');\n\nconst ARROW = ' \\u203A ';\nconst FAIL_COLOR = chalk.bold.red;\nconst SNAPSHOT_ADDED = chalk.bold.green;\nconst SNAPSHOT_NOTE = chalk.dim;\nconst SNAPSHOT_REMOVED = chalk.bold.red;\nconst SNAPSHOT_SUMMARY = chalk.bold;\nconst SNAPSHOT_UPDATED = chalk.bold.green;\nconst TEST_SUMMARY_THRESHOLD = 20;\n\nconst NPM_EVENTS = new Set([\n'prepublish',\n'publish',\n'postpublish',\n'preinstall',\n'install',\n'postinstall',\n'preuninstall',\n'uninstall',\n'postuninstall',\n'preversion',\n'version',\n'postversion',\n'pretest',\n'test',\n'posttest',\n'prestop',\n'stop',\n'poststop',\n'prestart',\n'start',\n'poststart',\n'prerestart',\n'restart',\n'postrestart']);\n\n\nclass SummareReporter extends BaseReporter {\n\n\n\n  constructor() {\n    super();\n    this._estimatedTime = 0;\n  }\n\n  // If we write more than one character at a time it is possible that\n  // Node.js exits in the middle of printing the result. This was first observed\n  // in Node.js 0.10 and still persists in Node.js 6.7+.\n  // Let's print the test failure summary character by character which is safer\n  // when hundreds of tests are failing.\n  _write(string) {\n    for (let i = 0; i < string.length; i++) {\n      process.stderr.write(string.charAt(i));\n    }\n  }\n\n  onRunStart(\n  config,\n  aggregatedResults,\n  runnerContext,\n  options)\n  {\n    super.onRunStart(config, aggregatedResults, runnerContext, options);\n    this._estimatedTime = options.estimatedTime;\n  }\n\n  onRunComplete(\n  config,\n  aggregatedResults,\n  runnerContext)\n  {const\n    numTotalTestSuites = aggregatedResults.numTotalTestSuites,testResults = aggregatedResults.testResults,wasInterrupted = aggregatedResults.wasInterrupted;\n    if (numTotalTestSuites) {\n      const lastResult = testResults[testResults.length - 1];\n      // Print a newline if the last test did not fail to line up newlines\n      // similar to when an error would have been thrown in the test.\n      if (\n      !config.verbose &&\n      lastResult &&\n      !lastResult.numFailingTests &&\n      !lastResult.testExecError)\n      {\n        this.log('');\n      }\n\n      this._printSummary(aggregatedResults, config);\n      this._printSnapshotSummary(aggregatedResults.snapshot, config);\n\n      if (numTotalTestSuites) {\n        const testSummary = wasInterrupted ?\n        chalk.bold.red('Test run was interrupted.') :\n        runnerContext.getTestSummary();\n        this.log(\n        getSummary(aggregatedResults, {\n          estimatedTime: this._estimatedTime }) +\n        '\\n' + testSummary);\n\n      }\n    }\n  }\n\n  _printSnapshotSummary(snapshots, config) {\n    if (\n    snapshots.added ||\n    snapshots.filesRemoved ||\n    snapshots.unchecked ||\n    snapshots.unmatched ||\n    snapshots.updated)\n    {\n      let updateCommand;\n      const event = process.env.npm_lifecycle_event;\n      const prefix = NPM_EVENTS.has(event) ? '' : 'run ';\n      if (config.watch) {\n        updateCommand = 'press `u`';\n      } else if (event) {\n        updateCommand = `run with \\`npm ${prefix + event} -- -u\\``;\n      } else {\n        updateCommand = 're-run with `-u`';\n      }\n\n      this.log(SNAPSHOT_SUMMARY('Snapshot Summary'));\n      if (snapshots.added) {\n        this.log(\n        SNAPSHOT_ADDED(ARROW + pluralize('snapshot', snapshots.added)) +\n        ` written in ${pluralize('test suite', snapshots.filesAdded)}.`);\n\n      }\n\n      if (snapshots.unmatched) {\n        this.log(\n        FAIL_COLOR(ARROW + pluralize('snapshot test', snapshots.unmatched)) +\n        ` failed in ${pluralize('test suite', snapshots.filesUnmatched)}. ` +\n        SNAPSHOT_NOTE(\n        'Inspect your code changes or ' +\n        updateCommand + ' to update them.'));\n\n\n      }\n\n      if (snapshots.updated) {\n        this.log(\n        SNAPSHOT_UPDATED(ARROW + pluralize('snapshot', snapshots.updated)) +\n        ` updated in ${pluralize('test suite', snapshots.filesUpdated)}.`);\n\n      }\n\n      if (snapshots.filesRemoved) {\n        this.log(\n        SNAPSHOT_REMOVED(ARROW + pluralize(\n        'obsolete snapshot file',\n        snapshots.filesRemoved)) + (\n\n        snapshots.didUpdate ?\n        ' removed.' :\n        ' found, ' + updateCommand + ' to remove ' + (\n        snapshots.filesRemoved === 1 ? 'it' : 'them.') + '.'));\n\n      }\n\n      if (snapshots.unchecked) {\n        this.log(\n        FAIL_COLOR(ARROW + pluralize(\n        'obsolete snapshot',\n        snapshots.unchecked)) + (\n\n        snapshots.didUpdate ?\n        ' removed.' :\n        ' found, ' + updateCommand + ' to remove ' + (\n        snapshots.filesRemoved === 1 ? 'it' : 'them') + '.'));\n\n      }\n\n      this.log(''); // print empty line\n    }\n  }\n\n  _printSummary(aggregatedResults, config) {\n    // If there were any failing tests and there was a large number of tests\n    // executed, re-print the failing results at the end of execution output.\n    const failedTests = aggregatedResults.numFailedTests;\n    const runtimeErrors = aggregatedResults.numRuntimeErrorTestSuites;\n    if (\n    failedTests + runtimeErrors > 0 &&\n    aggregatedResults.numTotalTestSuites > TEST_SUMMARY_THRESHOLD)\n    {\n      this.log(chalk.bold('Summary of all failing tests'));\n      aggregatedResults.testResults.forEach(testResult => {const\n        failureMessage = testResult.failureMessage;\n        if (failureMessage) {\n          this._write(\n          getResultHeader(testResult, config) + '\\n' +\n          failureMessage + '\\n');\n\n        }\n      });\n      this.log(''); // print empty line\n    }\n  }}\n\n\nmodule.exports = SummareReporter;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/reporters/VerboseReporter.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\n\n\n\n\n\n\nconst DefaultReporter = require('./DefaultReporter');\nconst chalk = require('chalk');var _require =\nrequire('../constants');const ICONS = _require.ICONS;\n\nclass VerboseReporter extends DefaultReporter {\n\n\n  constructor(config) {\n    super();\n    this._config = config;\n  }\n\n  static filterTestResults(testResults) {\n    return testResults.filter((_ref) => {let status = _ref.status;return status !== 'pending';});\n  }\n\n  static groupTestsBySuites(testResults) {\n    const root = { suites: [], tests: [], title: '' };\n    testResults.forEach(testResult => {\n      let targetSuite = root;\n\n      // Find the target suite for this test,\n      // creating nested suites as necessary.\n      for (const title of testResult.ancestorTitles) {\n        let matchingSuite = targetSuite.suites.find(s => s.title === title);\n        if (!matchingSuite) {\n          matchingSuite = { suites: [], tests: [], title };\n          targetSuite.suites.push(matchingSuite);\n        }\n        targetSuite = matchingSuite;\n      }\n\n      targetSuite.tests.push(testResult);\n    });\n    return root;\n  }\n\n  onTestResult(\n  config,\n  result,\n  aggregatedResults)\n  {\n    super.onTestResult(config, result, aggregatedResults);\n    if (!result.testExecError && !result.skipped) {\n      this._logTestResults(result.testResults);\n    }\n  }\n\n  _logTestResults(testResults) {\n    this._logSuite(VerboseReporter.groupTestsBySuites(testResults), 0);\n    this._logLine();\n  }\n\n  _logSuite(suite, indentLevel) {\n    if (suite.title) {\n      this._logLine(suite.title, indentLevel);\n    }\n\n    this._logTests(suite.tests, indentLevel + 1);\n\n    suite.suites.forEach(suite => this._logSuite(suite, indentLevel + 1));\n  }\n\n  _getIcon(status) {\n    if (status === 'failed') {\n      return chalk.red(ICONS.failed);\n    } else if (status === 'pending') {\n      return chalk.yellow(ICONS.pending);\n    } else {\n      return chalk.green(ICONS.success);\n    }\n  }\n\n  _logTest(test, indentLevel) {\n    const status = this._getIcon(test.status);\n    const time = test.duration ?\n    ` (${test.duration.toFixed(0)}ms)` :\n    '';\n    this._logLine(status + ' ' + chalk.dim(test.title + time), indentLevel);\n  }\n\n  _logTests(tests, indentLevel) {\n    const config = this._config;\n\n    if (config.expand) {\n      tests.forEach(test => this._logTest(test, indentLevel));\n    } else {\n      const skippedCount = tests.reduce((result, test) => {\n        if (test.status === 'pending') {\n          result += 1;\n        } else {\n          this._logTest(test, indentLevel);\n        }\n\n        return result;\n      }, 0);\n\n      if (skippedCount > 0) {\n        this._logSkippedTests(skippedCount, indentLevel);\n      }\n    }\n  }\n\n  _logSkippedTests(count, indentLevel) {\n    const icon = this._getIcon('pending');\n    const text = chalk.dim(`skipped ${count} test${count === 1 ? '' : 's'}`);\n\n    this._logLine(`${icon} ${text}`, indentLevel);\n  }\n\n  _logLine(str, indentLevel) {\n    const indentation = '  '.repeat(indentLevel || 0);\n    this.log(indentation + (str || ''));\n  }}\n\n\n\nmodule.exports = VerboseReporter;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/constants.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\nconst isWindows = process.platform === 'win32';\n\nconst CLEAR = isWindows ? '\\x1Bc' : '\\x1B[2J\\x1B[3J\\x1B[H';\n\nconst KEYS = {\n  A: '61',\n  ARROW_DOWN: '1b5b42',\n  ARROW_LEFT: '1b5b44',\n  ARROW_RIGHT: '1b5b43',\n  ARROW_UP: '1b5b41',\n  BACKSPACE: isWindows ? '08' : '7f',\n  CONTROL_C: '03',\n  CONTROL_D: '04',\n  ENTER: '0d',\n  ESCAPE: '1b',\n  O: '6f',\n  P: '70',\n  Q: '71',\n  QUESTION_MARK: '3f',\n  T: '74',\n  U: '75' };\n\n\nconst ICONS = {\n  failed: isWindows ? '\\u00D7' : '\\u2715',\n  pending: '\\u25CB',\n  success: isWindows ? '\\u221A' : '\\u2713' };\n\n\nmodule.exports = { CLEAR, ICONS, KEYS };","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/lib/promisify.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nmodule.exports = function promisify(fn) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise((resolve, reject) => {\n      args.push((err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(this, args);\n    });\n  };\n};","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/runTest.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\n\n\nconst BufferedConsole = require('./lib/BufferedConsole');var _require =\n\n\n\n\nrequire('jest-util');const Console = _require.Console,NullConsole = _require.NullConsole,setGlobal = _require.setGlobal;\nconst getConsoleOutput = require('./reporters/getConsoleOutput');\n\nfunction runTest(path, config, resolver) {\n  /* $FlowFixMe */\n  const TestEnvironment = require(config.testEnvironment);\n  /* $FlowFixMe */\n  const TestRunner = require(config.testRunner);\n  /* $FlowFixMe */\n  const ModuleLoader = require(config.moduleLoader || 'jest-runtime');\n\n  const env = new TestEnvironment(config);\n  const TestConsole =\n  config.verbose ?\n  Console :\n  config.silent ?\n  NullConsole :\n  BufferedConsole;\n\n  const testConsole = new TestConsole(\n  config.useStderr ? process.stderr : process.stdout,\n  process.stderr,\n  (type, message) => getConsoleOutput(\n  config.rootDir,\n  !!config.verbose,\n  // 4 = the console call is burried 4 stack frames deep\n  BufferedConsole.write([], type, message, 4)));\n\n\n  setGlobal(env.global, 'console', testConsole);\n  const runtime = new ModuleLoader(config, env, resolver);\n  const start = Date.now();\n  return TestRunner(config, env, runtime, path).\n  then(result => {\n    const testCount =\n    result.numPassingTests +\n    result.numFailingTests +\n    result.numPendingTests;\n    result.perfStats = { end: Date.now(), start };\n    result.testFilePath = path;\n    result.coverage = runtime.getAllCoverageInfo();\n    result.console = testConsole.getBuffer();\n    result.skipped = testCount === result.numPendingTests;\n    return result;\n  }).\n  then(\n  result => Promise.resolve().then(() => {\n    env.dispose();\n    if (config.logHeapUsage) {\n      if (global.gc) {\n        global.gc();\n      }\n      result.memoryUsage = process.memoryUsage().heapUsed;\n    }\n\n    // Delay the resolution to allow log messages to be output.\n    return new Promise(resolve => setImmediate(() => resolve(result)));\n  }),\n  err => Promise.resolve().then(() => {\n    env.dispose();\n    throw err;\n  }));\n\n}\n\nmodule.exports = runTest;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/lib/BufferedConsole.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n\n\nconst Console = require('console').Console;\n\nconst callsites = require('callsites');\nconst format = require('util').format;\n\nclass BufferedConsole extends Console {\n\n\n\n  constructor() {\n    const buffer = [];\n    super({ write: message => BufferedConsole.write(buffer, 'log', message) });\n    this._buffer = buffer;\n  }\n\n  static write(\n  buffer,\n  type,\n  message,\n  level)\n  {\n    const call = callsites()[level != null ? level : 2];\n    const origin = call.getFileName() + ':' + call.getLineNumber();\n    buffer.push({ message, origin, type });\n    return buffer;\n  }\n\n  log() {\n    BufferedConsole.write(this._buffer, 'log', format.apply(null, arguments));\n  }\n\n  info() {\n    BufferedConsole.write(this._buffer, 'info', format.apply(null, arguments));\n  }\n\n  warn() {\n    BufferedConsole.write(this._buffer, 'warn', format.apply(null, arguments));\n  }\n\n  error() {\n    BufferedConsole.write(this._buffer, 'error', format.apply(null, arguments));\n  }\n\n  getBuffer() {\n    return this._buffer;\n  }}\n\n\n\nmodule.exports = BufferedConsole;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/TestWatcher.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';var _require =\n\nrequire('events');const EventEmitter = _require.EventEmitter;\n\n\n\n\n\nclass TestWatcher extends EventEmitter {\n\n\n\n  constructor(_ref) {let isWatchMode = _ref.isWatchMode;\n    super();\n    this.state = { interrupted: false };\n    this._isWatchMode = isWatchMode;\n  }\n\n  setState(state) {\n    Object.assign(this.state, state);\n    this.emit('change', this.state);\n  }\n\n  isInterrupted() {\n    return this.state.interrupted;\n  }\n\n  isWatchMode() {\n    return this._isWatchMode;\n  }}\n\n\n\nmodule.exports = TestWatcher;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/lib/createHasteContext.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\n\n\n\nconst Runtime = require('jest-runtime');\n\nconst createHasteContext = (\nconfig, _ref) => {let\n  hasteFS = _ref.hasteFS,moduleMap = _ref.moduleMap;return (\n    {\n      hasteFS,\n      moduleMap,\n      resolver: Runtime.createResolver(config, moduleMap) });};\n\n\nmodule.exports = createHasteContext;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/lib/getMaxWorkers.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nconst os = require('os');\n\n// eslint-disable-next-line arrow-parens\nconst getMaxWorkers = argv => {\n  if (argv.runInBand) {\n    return 1;\n  } else if (argv.maxWorkers) {\n    return parseInt(argv.maxWorkers, 10);\n  } else {\n    const cpus = os.cpus().length;\n    return Math.max(argv.watch ? Math.floor(cpus / 2) : cpus - 1, 1);\n  }\n};\n\nmodule.exports = getMaxWorkers;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/lib/logDebugMessages.js":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\n\n\nconst VERSION = require('../../package.json').version;\n\nconst logDebugMessages = (\nconfig,\npipe) =>\n{\n  /* $FlowFixMe */\n  const testFramework = require(config.testRunner);\n  pipe.write('jest version = ' + VERSION + '\\n');\n  pipe.write('test framework = ' + testFramework.name + '\\n');\n  pipe.write('config = ' + JSON.stringify(config, null, '  ') + '\\n');\n\n};\n\nmodule.exports = logDebugMessages;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/bin/jest.js":"#!/usr/bin/env node\n/**\n * Copyright (c) 2014, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV == null) {\n  process.env.NODE_ENV = 'test';\n}\n\nrequire('../build/cli').run();\n","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/cli/index.js":"/**\n * Copyright (c) 2014, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\n\n\nconst args = require('./args');\nconst getJest = require('./getJest');\nconst getPackageRoot = require('jest-util').getPackageRoot;\nconst validateCLIOptions = require('jest-util').validateCLIOptions;\nconst yargs = require('yargs');\n\nfunction run(argv, root) {\n  argv = yargs(argv || process.argv.slice(2)).\n  usage(args.usage).\n  help().\n  alias('help', 'h').\n  options(args.options).\n  check(args.check).\n  argv;\n\n  validateCLIOptions(argv, args.options);\n\n  if (argv.help) {\n    yargs.showHelp();\n    process.on('exit', () => process.exit(1));\n    return;\n  }\n\n  if (!root) {\n    root = getPackageRoot();\n  }\n\n  getJest(root).runCLI(argv, root, result => {\n    const code = !result || result.success ? 0 : 1;\n    process.on('exit', () => process.exit(code));\n    if (argv && argv.forceExit) {\n      process.exit(code);\n    }\n  });\n}\n\nexports.run = run;","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/cli/args.js":"/**\n * Copyright (c) 2014, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\nconst check = argv => {\n  if (argv.runInBand && argv.hasOwnProperty('maxWorkers')) {\n    throw new Error(\n    'Both --runInBand and --maxWorkers were specified, but these two ' +\n    'options do not make sense together. Which is it?');\n\n  }\n\n  if (argv.onlyChanged && argv._.length > 0) {\n    throw new Error(\n    'Both --onlyChanged and a path pattern were specified, but these ' +\n    'two options do not make sense together. Which is it? Do you want ' +\n    'to run tests for changed files? Or for a specific set of files?');\n\n  }\n\n  if (argv.onlyChanged && argv.watchAll) {\n    throw new Error(\n    'Both --onlyChanged and --watchAll were specified, but these two ' +\n    'options do not make sense together. Try the --watch option which ' +\n    'reruns only tests related to changed files.');\n\n  }\n\n  if (argv.findRelatedTests && argv._.length === 0) {\n    throw new Error(\n    'The --findRelatedTests option requires file paths to be specified.\\n' +\n    'Example usage: jest --findRelatedTests ./src/source.js ./src/index.js.');\n\n  }\n\n  return true;\n};\n\nconst usage = 'Usage: $0 [--config=<pathToConfigFile>] [TestPathPattern]';\n\nconst options = {\n  bail: {\n    alias: 'b',\n    description:\n    'Exit the test suite immediately upon the first failing test.',\n    type: 'boolean' },\n\n  cache: {\n    default: true,\n    description:\n    'Whether to use the transform cache. Disable the cache using ' +\n    '--no-cache.',\n    type: 'boolean' },\n\n  collectCoverageFrom: {\n    description:\n    'relative to <rootDir> glob pattern matching the files that coverage ' +\n    'info needs to be collected from.',\n    type: 'string' },\n\n  collectCoverageOnlyFrom: {\n    description: 'List of paths coverage will be restricted to.',\n    type: 'array' },\n\n  color: {\n    description:\n    'Forces test results output color highlighting (even if stdout is not ' +\n    'a TTY). Set to false if you would like to have no colors.',\n    type: 'boolean' },\n\n  colors: {\n    description:\n    'Alias for `--color`.',\n    type: 'boolean' },\n\n  config: {\n    alias: 'c',\n    description:\n    'The path to a jest config file specifying how to find and execute ' +\n    'tests. If no rootDir is set in the config, the current directory ' +\n    'is assumed to be the rootDir for the project. This can also be a JSON' +\n    'encoded value which Jest will use as configuration.',\n    type: 'string' },\n\n  coverage: {\n    description:\n    'Indicates that test coverage information should be collected and ' +\n    'reported in the output.',\n    type: 'boolean' },\n\n  coverageDirectory: {\n    default: undefined,\n    description: 'The directory where Jest should output its coverage files.',\n    type: 'string' },\n\n  debug: {\n    description: 'Print debugging info about your jest config.',\n    type: 'boolean' },\n\n  env: {\n    default: undefined,\n    description:\n    'The test environment used for all tests. This can point to any file ' +\n    'or node module. Examples: `jsdom`, `node` or ' +\n    '`path/to/my-environment.js`',\n    type: 'string' },\n\n  expand: {\n    alias: 'e',\n    default: false,\n    description: 'Use this flag to show full diffs instead of a patch.',\n    type: 'boolean' },\n\n  findRelatedTests: {\n    description:\n    'Find related tests for a list of source files that were passed in ' +\n    'as arguments. Useful for pre-commit hook integration to run the ' +\n    'minimal amount of tests necessary.',\n    type: 'boolean' },\n\n  forceExit: {\n    default: false,\n    description:\n    'Force Jest to exit after all tests have completed running. ' +\n    'This is useful when resources set up by test code cannot be ' +\n    'adequately cleaned up.',\n    type: 'boolean' },\n\n  json: {\n    description:\n    'Prints the test results in JSON. This mode will send all ' +\n    'other test output and user messages to stderr.',\n    type: 'boolean' },\n\n  lastCommit: {\n    default: false,\n    description:\n    'Will run all tests affected by file changes in the last commit made.',\n    type: 'boolean' },\n\n  logHeapUsage: {\n    description:\n    'Logs the heap usage after every test. Useful to debug memory ' +\n    'leaks. Use together with `--runInBand` and `--expose-gc` in node.',\n    type: 'boolean' },\n\n  maxWorkers: {\n    alias: 'w',\n    description:\n    'Specifies the maximum number of workers the worker-pool will ' +\n    'spawn for running tests. This defaults to the number of the cores ' +\n    'available on your machine. (its usually best not to override this ' +\n    'default)',\n    type: 'string' },\n\n  noStackTrace: {\n    description: 'Disables stack trace in test results output',\n    type: 'boolean' },\n\n  notify: {\n    description: 'Activates notifications for test results.',\n    type: 'boolean' },\n\n  onlyChanged: {\n    alias: 'o',\n    description:\n    'Attempts to identify which tests to run based on which files have ' +\n    'changed in the current repository. Only works if you\\'re running ' +\n    'tests in a git repository at the moment.',\n    type: 'boolean' },\n\n  outputFile: {\n    description:\n    'Write test results to a file when the --json option is also specified.',\n    type: 'string' },\n\n  runInBand: {\n    alias: 'i',\n    description:\n    'Run all tests serially in the current process (rather than ' +\n    'creating a worker pool of child processes that run tests). This ' +\n    'is sometimes useful for debugging, but such use cases are pretty ' +\n    'rare.',\n    type: 'boolean' },\n\n  setupTestFrameworkScriptFile: {\n    description:\n    'The path to a module that runs some code to configure or set up ' +\n    'the testing framework before each test.',\n    type: 'string' },\n\n  silent: {\n    default: false,\n    description: 'Prevent tests from printing messages through the console.',\n    type: 'boolean' },\n\n  testNamePattern: {\n    alias: 't',\n    description:\n    'Run only tests with a name that matches the regex pattern.',\n    type: 'string' },\n\n  testPathPattern: {\n    description:\n    'A regexp pattern string that is matched against all tests ' +\n    'paths before executing the test.',\n    type: 'string' },\n\n  testResultsProcessor: {\n    default: undefined,\n    description:\n    'Allows the use of a custom results processor. ' +\n    'This processor must be a node module that exports ' +\n    'a function expecting as the first argument the result object',\n    type: 'string' },\n\n  testRunner: {\n    description:\n    'Allows to specify a custom test runner. Jest ships with Jasmine ' +\n    '1 and 2 which can be enabled by setting this option to ' +\n    '`jasmine1` or `jasmine2`. The default is `jasmine2`. A path to a ' +\n    'custom test runner can be provided: ' +\n    '`<rootDir>/path/to/testRunner.js`.',\n    type: 'string' },\n\n  updateSnapshot: {\n    alias: 'u',\n    default: false,\n    description:\n    'Use this flag to re-record snapshots. ' +\n    'Can be used together with a test suite pattern or with ' +\n    '`--testNamePattern` to re-record snapshot for test matching ' +\n    'the pattern',\n    type: 'boolean' },\n\n  useStderr: {\n    description: 'Divert all output to stderr.',\n    type: 'boolean' },\n\n  verbose: {\n    description:\n    'Display individual test results with the test suite hierarchy.',\n    type: 'boolean' },\n\n  version: {\n    alias: 'v',\n    description: 'Print the version and exit',\n    type: 'boolean' },\n\n  watch: {\n    description:\n    'Watch files for changes and rerun tests related to changed files. ' +\n    'If you want to re-run all tests when a file has changed, use the ' +\n    '`--watchAll` option.',\n    type: 'boolean' },\n\n  watchAll: {\n    description:\n    'Watch files for changes and rerun all tests. If you want to re-run ' +\n    'only the tests related to the changed files, use the ' +\n    '`--watch` option.',\n    type: 'boolean' },\n\n  watchman: {\n    default: true,\n    description:\n    'Whether to use watchman for file crawling. Disable using ' +\n    '--no-watchman.',\n    type: 'boolean' } };\n\n\n\nmodule.exports = {\n  check,\n  options,\n  usage };","/home/travis/build/npmtest/node-npmtest-jest-cli/node_modules/jest-cli/build/cli/getJest.js":"/**\n * Copyright (c) 2014, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\n\n\nconst chalk = require('chalk');\nconst fs = require('graceful-fs');\nconst path = require('path');\n\nfunction getJest(packageRoot) {\n  const packageJSONPath = path.join(packageRoot, 'package.json');\n  const binPath = path.join(packageRoot, 'node_modules/jest-cli');\n  if (fs.existsSync(binPath)) {\n    /* $FlowFixMe */\n    return require(binPath);\n  } else {\n    const jest = require('../jest');\n    // Check if Jest is specified in `package.json` but not installed.\n    if (fs.existsSync(packageJSONPath)) {\n      /* $FlowFixMe */\n      const packageJSON = require(packageJSONPath);\n      const dependencies = packageJSON.dependencies;\n      const devDependencies = packageJSON.devDependencies;\n      if (\n      dependencies && dependencies['jest-cli'] ||\n      devDependencies && devDependencies['jest-cli'])\n      {\n        process.on('exit', () => console.log(\n        chalk.red(\n        'Please run `npm install` to use the version of Jest intended ' +\n        'for this project.')));\n\n\n      }\n    }\n    return jest;\n  }\n}\n\nmodule.exports = getJest;"}